<?php
/**
 * ApiAuth
 *
 * PHP version 5
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

{{>partial_header}}
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace {{invokerPackage}};

/**
 * ApiAuth Class Doc Comment
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

class ApiAuth
{
    static private function _base_body_for_auth($grant_type, $client_secret = null)
    {
        $body = [
            "client_id" => Configuration::getDefaultConfiguration()->getClientId(),
            "grant_type" => $grant_type,
        ];

        if(Configuration::getDefaultConfiguration()->getScopes() != NULL)
            $body["scope"] = join('+', Configuration::getDefaultConfiguration()->getScopes());

        if($client_secret != NULL)
            $body["client_secret"] = $client_secret;

        return $body;
    }

    static private function _request_access_token($body)
    {
        $curl = curl_init();
        $postData = http_build_query($body);
        $url = Configuration::getDefaultConfiguration()->getAuthUrl();
        $http_header = Configuration::getDefaultConfiguration()->getDefaultHeaders();
        curl_setopt($curl, CURLOPT_HTTPHEADER, $http_header);
        curl_setopt($curl, CURLOPT_POST, true);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
        curl_setopt($curl, CURLOPT_URL, $url);
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($curl, CURLOPT_HEADER, 1);

        $response = curl_exec($curl);
        $http_header_size = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $http_body = substr($response, $http_header_size);
        $response_info = curl_getinfo($curl);

        // debug HTTP response body
        if (Configuration::getDefaultConfiguration()->getDebug()) {
            error_log("[DEBUG] HTTP Response body ~BEGIN~".PHP_EOL.print_r($http_body, true).PHP_EOL."~END~".PHP_EOL, 3, Configuration::getDefaultConfiguration()->getDebugFile());
        }

        // Handle the response
        if ($response_info['http_code'] == 0) {
            $curl_error_message = curl_error($curl);

            // curl_exec can sometimes fail but still return a blank message from curl_error().
            if (!empty($curl_error_message)) {
                $error_message = "API call to $url failed: $curl_error_message";
            } else {
                $error_message = "API call to $url failed, but for an unknown reason. " .
                    "This could happen if you are disconnected from the network.";
            }

            $exception = new ApiException($error_message, 0, null, null);
            $exception->setResponseObject($response_info);
            throw $exception;
        } elseif ($response_info['http_code'] >= 200 && $response_info['http_code'] <= 299) {
            $data = json_decode($http_body, true);
            if (json_last_error() > 0) { // if response is a string
                $data = $http_body;
            }
            $access_token = new Model\AccessToken([
              "access_token" => $data["access_token"],
              "expires_in" => $data["expires_in"],
              "token_type" => $data["token_type"]
            ]);
            Configuration::getDefaultConfiguration()->setAccessToken($access_token);
        } else {
            $data = json_decode($http_body);
            if (json_last_error() > 0) { // if response is a string
                $data = $http_body;
            }

            throw new ApiException(
                "[".$response_info['http_code']."] Error connecting to the API ($url)",
                $response_info['http_code'],
                $http_header,
                $data
            );
        }
    }

    static public function login($username, $password, $client_secret = null)
    {
        $body = ApiAuth::_base_body_for_auth("password", $client_secret);
        $body["username"] = $username;
        $body["password"] = $password;
        return ApiAuth::_request_access_token($body);
    }

    static public function authenticate($client_secret = null)
    {
        $body = ApiAuth::_base_body_for_auth("client_credentials", $client_secret);
        return ApiAuth::_request_access_token($body);
    }

    static public function startImpersonate($impersonation_access_token)
    {
        if(empty($impersonation_access_token)) {
            throw new \InvalidArgumentException("Must provide an non-empty impersonation access token");
        }

        Configuration::getDefaultConfiguration()->setImpersonationToken($impersonation_access_token);
    }

    static public function stopImpersonate()
    {
        Configuration::getDefaultConfiguration()->setImpersonationToken(NULL);
    }
}
